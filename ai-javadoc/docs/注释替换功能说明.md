# 注释替换功能说明

## 📋 问题描述

### 原有问题

在 v2.1 之前，当配置为**不跳过已有文档**时：

```java
// Before (旧注释)
/**
 * old comment
 */
public void method() {
    // ...
}

// After 生成新注释（问题：旧注释没有删除）
/**
 * old comment
 */
/**
 * 新生成的注释
 */
public void method() {
    // ...
}
```

**问题**：

- ❌ 旧注释没有被删除
- ❌ 出现了重复的注释
- ❌ 代码格式混乱

---

## ✅ 解决方案

### 核心思路

1. **构建提示词时包含已有注释**
    - AI 可以看到当前的注释
    - AI 可以理解现有注释的问题
    - AI 可以生成更准确的改进版本

2. **插入新注释时替换旧注释**
    - 先删除旧注释
    - 再插入新注释
    - 保持代码整洁

---

## 🔧 实现细节

### 1. TaskCollector - 获取代码时包含注释

**文件**：`src/main/java/com/github/intellijjavadocai/task/TaskCollector.java`

**新增方法**：

```java
/**
 * 获取元素的代码，包含已有的 JavaDoc 注释
 * 
 * @param element PSI 元素
 * @return 包含注释的完整代码
 */
@NotNull
private String getCodeWithComment(@NotNull PsiElement element) {
    // 如果元素有 JavaDoc 注释，将注释和代码一起返回
    if (element instanceof PsiDocCommentOwner) {
        PsiDocComment docComment = ((PsiDocCommentOwner) element).getDocComment();
        if (docComment != null) {
            // 返回注释 + 代码
            return docComment.getText() + "\n" + element.getText();
        }
    }
    
    // 没有注释，只返回代码
    return element.getText();
}
```

**修改 createTask 方法**：

```java
@NotNull
private DocumentationTask createTask(@NotNull PsiElement element,
                                     @NotNull DocumentationTask.TaskType type) {
    // 获取代码，包含已有的 JavaDoc 注释
    String code = getCodeWithComment(element);  // ← 使用新方法
    String filePath = element.getContainingFile().getVirtualFile().getPath();
    return new DocumentationTask(element, code, type, filePath);
}
```

**效果**：

- ✅ 传给 AI 的代码包含了旧注释
- ✅ AI 可以看到并改进现有注释
- ✅ 提高生成质量

---

### 2. TaskExecutor - 插入前删除旧注释

**文件**：`src/main/java/com/github/intellijjavadocai/task/TaskExecutor.java`

**新增方法**：

```java
/**
 * 删除元素的旧 JavaDoc 注释
 * 
 * @param element 目标元素
 * @param document 文档对象
 */
private void deleteOldDocComment(@NotNull PsiElement element, @NotNull Document document) {
    if (!(element instanceof PsiDocCommentOwner)) {
        return;
    }

    PsiDocComment oldComment = ((PsiDocCommentOwner) element).getDocComment();
    if (oldComment == null) {
        return;
    }

    try {
        // 获取注释的文本范围
        int startOffset = oldComment.getTextRange().getStartOffset();
        int endOffset = oldComment.getTextRange().getEndOffset();

        // 获取注释所在的行
        int startLine = document.getLineNumber(startOffset);
        int endLine = document.getLineNumber(endOffset);

        // 如果注释独占一行或多行，删除整行（包括换行符）
        if (startOffset == document.getLineStartOffset(startLine)) {
            // 删除到下一行的开始（包括换行符）
            int deleteEnd = document.getLineStartOffset(endLine + 1);
            // 确保不超出文档范围
            if (deleteEnd > document.getTextLength()) {
                deleteEnd = document.getTextLength();
            }
            document.deleteString(startOffset, deleteEnd);
        } else {
            // 注释不是独占一行，只删除注释本身
            document.deleteString(startOffset, endOffset);
        }
    } catch (Exception e) {
        log.warn("删除旧注释失败", e);
    }
}
```

**修改 insertDocumentation 方法**：

```java
private void insertDocumentation(@NotNull DocumentationTask task, @NotNull String documentation) {
    ApplicationManager.getApplication().invokeLater(() -> {
        // ... 省略前面的代码

        CommandProcessor.getInstance().executeCommand(
            project,
            () -> ApplicationManager.getApplication().runWriteAction(() -> {
                try {
                    // 1. 先删除旧注释（如果存在）
                    deleteOldDocComment(element, document);

                    // 2. 提交删除操作
                    PsiDocumentManager.getInstance(project).commitDocument(document);

                    // 3. 获取插入位置（删除后需要重新获取）
                    int startPosition = getInsertPosition(element);
                    
                    // 4. 插入新 JavaDoc
                    // ...
                    
                } catch (Exception e) {
                    log.info("插入文档失败", e);
                }
            }),
            "Insert JavaDoc",
            "AI Javadoc"
        );
    });
}
```

**关键点**：

- ✅ 先删除旧注释
- ✅ 提交删除操作（commit）
- ✅ 重新获取插入位置（因为文档已变化）
- ✅ 插入新注释

**处理细节**：

1. **多行注释**：删除整行（包括换行符）
2. **同行注释**：只删除注释本身
3. **边界检查**：确保不超出文档范围
4. **异常处理**：删除失败时记录警告

---

## 📊 使用示例

### 示例 1：改进现有注释

**Before**：

```java
/**
 * old comment
 */
public void calculateTotal() {
    // ...
}
```

**操作**：

1. 取消勾选"跳过已有文档的元素"
2. 在方法上生成 JavaDoc

**传给 AI 的内容**：

```
/**
 * old comment
 */
public void calculateTotal() {
    // ...
}
```

**AI 返回**：

```java
/**
 * 计算总金额
 * 
 * @return 总金额
 */
```

**After**（旧注释被替换）：

```java
/**
 * 计算总金额
 * 
 * @return 总金额
 */
public void calculateTotal() {
    // ...
}
```

---

### 示例 2：修复错误的注释

**Before**：

```java
/**
 * 获取用户名
 */
public String getUserId() {  // 注释错误，实际是获取 ID
    return this.userId;
}
```

**操作**：重新生成注释

**传给 AI 的内容**：

```
/**
 * 获取用户名
 */
public String getUserId() {
    return this.userId;
}
```

**AI 识别问题并返回**：

```java
/**
 * 获取用户 ID
 * 
 * @return 用户 ID
 */
```

**After**（错误注释被修正）：

```java
/**
 * 获取用户 ID
 * 
 * @return 用户 ID
 */
public String getUserId() {
    return this.userId;
}
```

---

### 示例 3：标准化注释格式

**Before**（非标准格式）：

```java
/* 用户名 */
private String username;
```

**操作**：重新生成注释

**传给 AI 的内容**：

```
/* 用户名 */
private String username;
```

**AI 返回标准格式**：

```java
/** 用户名 */
```

**After**（格式已标准化）：

```java
/** 用户名 */
private String username;
```

---

## 🎯 使用场景

### 1. 批量改进现有注释

**场景**：项目中已有注释，但质量不高或格式不统一

**操作步骤**：

1. 打开插件设置
2. **取消勾选** "跳过已有文档的元素"
3. 右键点击项目根目录
4. 选择 "Generate JavaDoc with AI for Directory"
5. 等待处理完成

**效果**：

- ✅ 所有现有注释被 AI 改进
- ✅ 格式统一为标准 JavaDoc
- ✅ 内容更准确、更详细

---

### 2. 修复错误的注释

**场景**：代码重构后，注释没有更新，出现不一致

**操作步骤**：

1. 确保"跳过已有文档的元素" **未勾选**
2. 在错误的注释上生成新注释
3. AI 会根据代码生成正确的注释

**效果**：

- ✅ 注释与代码保持一致
- ✅ 避免误导性注释

---

### 3. 统一注释风格

**场景**：团队成员注释风格不统一

**操作步骤**：

1. 自定义 Prompt 模板（定义团队规范）
2. 取消勾选"跳过已有文档的元素"
3. 批量重新生成注释

**效果**：

- ✅ 所有注释遵循统一规范
- ✅ 提高代码可读性

---

## 📝 注意事项

### 1. 数据安全

**建议**：

- ✅ 使用版本控制（Git）
- ✅ 在重新生成前先提交代码
- ✅ 可以随时回滚

### 2. 审查生成结果

**建议**：

- ✅ 检查生成的注释是否准确
- ✅ 对于关键代码，手动审查
- ✅ 必要时微调生成结果

### 3. 选择性重新生成

**建议**：

- ✅ 可以只对特定文件或目录重新生成
- ✅ 不必一次性处理整个项目
- ✅ 逐步改进注释质量

---

## ✅ 优势总结

### 1. 智能改进

| Before    | After           |
|-----------|-----------------|
| AI 看不到旧注释 | ✅ AI 可以看到并改进旧注释 |
| 无法识别注释问题  | ✅ AI 可以识别并修正错误  |
| 只能生成新注释   | ✅ 可以改进现有注释      |

### 2. 代码整洁

| Before  | After    |
|---------|----------|
| 重复的注释   | ✅ 只有一个注释 |
| 格式混乱    | ✅ 格式统一   |
| 手动删除旧注释 | ✅ 自动替换   |

### 3. 工作效率

| Before    | After     |
|-----------|-----------|
| 需要手动删除旧注释 | ✅ 自动删除并替换 |
| 逐个处理      | ✅ 批量处理    |
| 耗时多       | ✅ 高效完成    |

---

## 🔗 相关文档

- [v2.1特性实现说明.md](v2.1特性实现说明.md)
- [线程安全问题修复说明.md](线程安全问题修复说明.md)
- [v2.0架构说明.md](v2.0架构说明.md)

