# 异常处理优化说明 V2

## 优化目标

**彻底移除异常抛出机制**，改为在错误发生时直接给用户提示，避免在 IDEA 中显示错误对话框，提升用户体验。

## 核心理念

**"不抛出异常，直接提示用户"**

- 底层方法出错时不 `throw`，而是返回 `null` 或记录日志
- 上层调用方检查返回值，根据情况给用户友好提示
- 设置页面使用 `MessageDialog`（`JOptionPane`）
- 编辑页面使用 `NotificationUtil`（通知气泡）

## 详细修改

### 1. AIServiceFactory.java

**修改前：**

```java
@NotNull
public static AIServiceProvider createProvider(@NotNull SettingsState settings) throws AIServiceException {
    // ... 出错时抛出异常
    throw new AIServiceException("不支持的 AI 提供商...", ErrorCode.CONFIGURATION_ERROR);
}
```

**修改后：**

```java
@Nullable
public static AIServiceProvider createProvider(@NotNull SettingsState settings) {
    Class<? extends AIServiceProvider> providerClass = PROVIDERS.get(providerId);
    if (providerClass == null) {
        String error = "不支持的 AI 提供商: " + providerId + "。当前支持的提供商：qianwen, ollama";
        Logger.getInstance(AIServiceFactory.class).error(error);
        return null;  // 不抛异常，返回 null
    }
    
    try {
        return providerClass.getDeclaredConstructor(SettingsState.class).newInstance(settings);
    } catch (Exception e) {
        String error = "创建 AI 提供商失败: " + providerId + "。请检查配置是否正确。";
        Logger.getInstance(AIServiceFactory.class).error(error, e);
        return null;  // 不抛异常，返回 null
    }
}
```

**关键变化：**

- 返回类型从 `@NotNull` 改为 `@Nullable`
- 移除 `throws AIServiceException`
- 出错时记录日志并返回 `null`

### 2. TaskExecutor.java

**修改前：**

```java
public TaskExecutor(@NotNull Project project, @NotNull ProgressIndicator indicator) throws AIServiceException {
    this.aiService = AIServiceFactory.createProvider(settings);
}
```

**修改后：**

```java
public TaskExecutor(@NotNull Project project, @NotNull ProgressIndicator indicator) {
    this.aiService = AIServiceFactory.createProvider(settings);  // 可能返回 null
}

// 添加检查方法
public boolean isServiceAvailable() {
    return aiService != null;
}

public void processTasks(@NotNull List<DocumentationTask> tasks) {
    // 在处理任务前检查服务是否可用
    if (!isServiceAvailable()) {
        log.info("AI 服务不可用，无法处理任务");
        indicator.setText("AI 服务配置错误");
        return;
    }
    // ... 继续处理
}
```

**关键变化：**

- 构造函数不再抛异常
- 添加 `isServiceAvailable()` 检查方法
- 在 `processTasks()` 中检查服务是否可用

### 3. 所有 Action 类

**修改前：**

```java
new Task.Backgroundable(project, "正在生成...", true) {
    @Override
    public void run(@NotNull ProgressIndicator indicator) {
        try {
            TaskExecutor executor = new TaskExecutor(project, indicator);
            executor.processTasks(tasks);
        } catch (AIServiceException e) {
            // 捕获异常并提示
            NotificationUtil.notifyErrorMessage(project, e.getMessage());
        }
    }
}
```

**修改后：**

```java
new Task.Backgroundable(project, "正在生成...", true) {
    @Override
    public void run(@NotNull ProgressIndicator indicator) {
        TaskExecutor executor = new TaskExecutor(project, indicator);
        
        // 检查服务是否可用
        if (!executor.isServiceAvailable()) {
            ApplicationManager.getApplication().invokeLater(() -> {
                NotificationUtil.notifyErrorMessage(project, 
                    "AI 服务配置错误，请在设置中检查 API Key、Base URL 等配置是否正确");
            });
            return;
        }
        
        executor.processTasks(tasks);
        // ... 显示结果
    }
}
```

**关键变化：**

- 移除 `try-catch` 块
- 检查 `executor.isServiceAvailable()`
- 不可用时直接显示通知并返回

**涉及的 Action 类：**

- `GenerateJavaDocForSelectionAction.java`
- `GenerateJavaDocIntentionAction.java`
- `GenerateJavaDocShortcutAction.java`
- `GenerateJavaDocForFileAction.java`
- `GenerateJavaDocGenerateAction.java`

### 4. JavaDocSettingsPanel.java

**修改前：**

```java
private void testConnection() {
    try {
        SettingsState testSettings = getSettings();
        AIServiceProvider provider = AIServiceFactory.createProvider(testSettings);
        // ... 测试连接
    } catch (AIServiceException e) {
        JOptionPane.showMessageDialog(mainPanel, getFriendlyErrorMessage(e), ...);
    }
}
```

**修改后：**

```java
private void testConnection() {
    SettingsState testSettings = getSettings();
    AIServiceProvider provider = AIServiceFactory.createProvider(testSettings);
    
    // 检查提供商创建是否成功
    if (provider == null) {
        JOptionPane.showMessageDialog(
            mainPanel,
            "创建 AI 服务提供商失败，请检查配置是否正确（提供商、模型、Base URL 等）",
            JavaDocBundle.message("settings.error.title"),
            JOptionPane.ERROR_MESSAGE
        );
        return;
    }
    
    // ... 继续测试连接
}
```

**关键变化：**

- 移除 `try-catch` 块
- 检查返回的 `provider` 是否为 `null`
- 为 `null` 时使用 `MessageDialog` 直接提示用户

### 5. AICompatibleProvider.java

**修改前：**

```java
protected HttpHeaders buildHeaders() throws AIServiceException {
    if (requiresApiKey()) {
        String apiKey = settings.apiKey;
        if (apiKey == null || apiKey.trim().isEmpty()) {
            throw new AIServiceException("API Key is required but not configured", 
                                        ErrorCode.CONFIGURATION_ERROR);
        }
        // ...
    }
    return headers;
}
```

**修改后：**

```java
protected HttpHeaders buildHeaders() {
    if (requiresApiKey()) {
        String apiKey = settings.apiKey;
        if (apiKey == null || apiKey.trim().isEmpty()) {
            LOG.info("API Key is required but not configured for provider: " + getProviderId());
            return null;  // 不抛异常，返回 null
        }
        // ...
    }
    return headers;
}

protected String sendRequest(String prompt) throws AIServiceException {
    HttpHeaders headers = buildHeaders();
    if (headers == null) {
        // 在这里统一转换为 AIServiceException（内部流程）
        throw new AIServiceException("Failed to build request headers: API Key is required...", 
                                    ErrorCode.CONFIGURATION_ERROR);
    }
    // ... 继续处理
}
```

**关键变化：**

- `buildHeaders()` 不再抛异常，返回 `null`
- `sendRequest()` 中检查 `headers` 是否为 `null`
- `AIServiceException` 只在内部流程中使用，不会传递到最外层

## 异常处理流程图

```
用户触发操作
    ↓
创建 TaskExecutor
    ↓
调用 AIServiceFactory.createProvider()
    ├─ 成功 → 返回 AIServiceProvider
    └─ 失败 → 返回 null（记录日志）
         ↓
    检查 executor.isServiceAvailable()
         ↓
    ┌────┴────┐
    ↓         ↓
  true      false
    ↓         ↓
 继续处理  显示通知 → 结束
    ↓
processTasks()
    ↓
处理每个任务
    ↓
├─ API Key 缺失 → buildHeaders() 返回 null → sendRequest() 抛出 AIServiceException
├─ 网络错误 → 抛出 AIServiceException
└─ 其他错误 → 抛出 AIServiceException
    ↓
processTask() 捕获异常
    ↓
转换为友好消息
    ↓
只在第一次失败时显示通知
```

## 用户体验改进

### 场景 1：设置页面测试连接

**优化前：**

- 点击测试按钮 → 抛出异常 → 显示技术错误

**优化后：**

- 点击测试按钮 → 检查 `provider == null` → 显示友好的 MessageDialog

### 场景 2：编辑页面生成文档

**优化前：**

- 快捷键生成 → 抛出异常 → 阻塞 UI → 显示错误

**优化后：**

- 快捷键生成 → 检查 `isServiceAvailable()` → 显示通知气泡（不阻塞）

### 场景 3：批量生成文档

**优化前：**

- 批量处理 → 第一个失败抛异常 → 中断所有任务

**优化后：**

- 批量处理 → 单个失败显示通知 → 继续其他任务 → 显示统计信息

## 关键代码变化总结

| 文件                          | 主要变化                                       | 目的          |
|-----------------------------|--------------------------------------------|-------------|
| `AIServiceFactory.java`     | `createProvider()` 返回 `null` 而不抛异常         | 让调用方决定如何处理  |
| `TaskExecutor.java`         | 构造函数不抛异常，添加 `isServiceAvailable()`         | 推迟错误检查到使用时  |
| 所有 Action 类                 | 移除 `try-catch`，改为检查 `isServiceAvailable()` | 主动检查而非被动捕获  |
| `JavaDocSettingsPanel.java` | 移除 `try-catch`，检查返回值是否为 `null`             | 直接检查而非捕获异常  |
| `AICompatibleProvider.java` | `buildHeaders()` 返回 `null` 而不抛异常           | 错误在调用链中逐级处理 |

## 优势

1. **代码更清晰**：没有复杂的异常传递链
2. **用户体验更好**：错误提示更友好，不阻塞操作
3. **维护性更强**：错误处理逻辑集中在调用方
4. **性能更优**：避免异常创建和堆栈追踪的开销

## 测试要点

1. **空 API Key**：检查是否正确提示而非抛异常
2. **错误的 Provider**：检查是否返回 `null` 并提示
3. **网络错误**：检查是否显示友好通知
4. **批量操作**：检查单个失败不影响整体流程

