# IntelliJ AI Javadoc 插件 - 集成测试说明

## 📚 测试概述

本文档介绍了插件的集成测试，特别是：

1. **JavaDoc 替换逻辑测试** - 使用 IntelliJ Platform Test Framework
2. **AI HTTP 调用测试** - 使用 MockWebServer 模拟真实 API

这些测试展示了如何使用 IntelliJ Platform SDK 的核心 API，是学习插件开发的绝佳示例。

## 🎯 测试文件

### 1. BasePlatformTestCase - 测试基类

**文件**: `src/test/java/com/github/intellijjavadocai/BasePlatformTestCase.java`

**作用**: 提供通用的测试工具方法

**关键学习点**:

#### 1.1 IntelliJ Platform 的 Read/Write Action

```java
// 读操作 - 所有 PSI 读取必须在 Read Action 中
protected <T> T runReadAction(@NotNull Computable<T> computation) {
    return ApplicationManager.getApplication().runReadAction(computation);
}

// 写操作 - 所有 PSI 修改必须在 Write Action 中
protected void runWriteAction(@NotNull Runnable runnable) {
    WriteCommandAction.runWriteCommandAction(getProject(), runnable);
}
```

**为什么需要**:

- IntelliJ Platform 是多线程的
- Read Action 确保读取时 PSI 树不被修改
- Write Action 锁定 PSI 树，确保线程安全

#### 1.2 Document 和 PSI 的同步

```java
// 获取 Document（编辑器视图）
protected Document getDocument(@NotNull PsiFile file) {
    return FileDocumentManager.getInstance().getDocument(file.getVirtualFile());
}

// 提交 Document 变更到 PSI（语义树）
protected void commitDocument(@NotNull PsiFile file) {
    Document document = getDocument(file);
    PsiDocumentManager.getInstance(getProject()).commitDocument(document);
}
```

**核心概念**:

- **Document**: 文本文件的编辑器表示（字符流）
- **PSI**: 代码的语义树表示（语法树）
- 修改 Document 后必须调用 `commitDocument` 同步到 PSI

#### 1.3 创建测试文件

```java
protected PsiJavaFile createJavaFile(@NotNull String fileName, @NotNull String content) {
    // fixture 是测试框架的核心工具
    PsiFile file = myFixture.configureByText(fileName, content);
    return (PsiJavaFile) file;
}
```

**fixture 提供的功能**:

- 创建临时项目
- 管理测试文件
- 提供编辑器环境
- 处理文件系统操作

### 2. TaskExecutorIntegrationTest - JavaDoc 替换逻辑测试

**文件**: `src/test/java/com/github/intellijjavadocai/task/TaskExecutorIntegrationTest.java`

**测试场景**:

1. ✅ 为没有 JavaDoc 的方法插入注释
2. ✅ 替换已有的 JavaDoc 注释
3. ✅ 为类添加 JavaDoc
4. ✅ 为字段添加 JavaDoc
5. ✅ 批量处理多个任务
6. ✅ 跳过已有文档的功能

#### 2.1 关键学习点：PSI 元素操作

##### 获取 PSI 元素

```java
// 获取类
PsiClass[] classes = file.getClasses();

// 获取方法
PsiMethod[] methods = psiClass.getMethods();

// 获取字段
PsiField[] fields = psiClass.getFields();

// 获取 JavaDoc
PsiDocComment docComment = method.getDocComment();
```

##### 遍历 PSI 树

```java
// 使用 Visitor 模式遍历 PSI 树
file.accept(new JavaRecursiveElementVisitor() {
    @Override
    public void visitClass(PsiClass aClass) {
        // 处理类
        super.visitClass(aClass);
    }
    
    @Override
    public void visitMethod(PsiMethod method) {
        // 处理方法
        super.visitMethod(method);
    }
});
```

#### 2.2 测试示例：插入 JavaDoc

```java
@Test
public void testInsertJavaDocForMethodWithoutExistingComment() {
    // 1. 创建测试文件
    String code = """
        public class TestClass {
            public String getUserName(int userId) {
                return "user_" + userId;
            }
        }
        """;
    PsiJavaFile file = createJavaFile("TestClass.java", code);
    
    // 2. 获取方法元素（在 Read Action 中）
    PsiMethod method = runReadAction(() -> {
        PsiClass[] classes = file.getClasses();
        return classes[0].getMethods()[0];
    });
    
    // 3. 验证没有 JavaDoc
    Boolean hasDoc = runReadAction(() -> 
        method.getDocComment() != null);
    assertFalse("Method should not have JavaDoc", hasDoc);
    
    // 4. 创建任务并执行
    String methodCode = runReadAction(() -> method.getText());
    DocumentationTask task = new DocumentationTask(
        method, methodCode, 
        DocumentationTask.TaskType.METHOD,
        file.getVirtualFile().getPath()
    );
    
    taskExecutor.processTasks(Arrays.asList(task));
    
    // 5. 等待异步操作完成
    waitForPendingWrites();
    
    // 6. 验证 JavaDoc 被插入
    String updatedContent = getFileText(file);
    assertTrue("Should have JavaDoc", 
        updatedContent.contains("/**"));
}
```

#### 2.3 Mock AI Service

为了测试不依赖真实 API，使用 Mock AI Service：

```java
private static class MockAIServiceProvider implements AIServiceProvider {
    @Override
    public String generateDocumentation(String code, 
                                       DocumentationType type,
                                       String language) {
        // 根据代码内容返回不同的 Mock 结果
        if (code.contains("getUserName")) {
            return """
                /**
                 * 根据用户ID获取用户名称
                 * @param userId 用户ID
                 * @return 用户名称
                 */
                """;
        }
        return "/** Mock JavaDoc */";
    }
    // ... 其他方法
}
```

**注入 Mock Service**:

```java
private void injectMockAIService(TaskExecutor executor) {
    try {
        Field field = TaskExecutor.class
            .getDeclaredField("aiService");
        field.setAccessible(true);
        field.set(executor, new MockAIServiceProvider());
    } catch (Exception e) {
        throw new RuntimeException("Failed to inject", e);
    }
}
```

#### 2.4 异步操作处理

IntelliJ Platform 的很多操作是异步的，测试中需要等待：

```java
private void waitForPendingWrites() {
    // 1. 提交所有 Document 变更
    PsiDocumentManager.getInstance(getProject())
        .commitAllDocuments();
    
    // 2. 处理 EDT 队列中的所有任务
    UIUtil.dispatchAllInvocationEvents();
    
    // 3. 稍微等待确保完成
    Thread.sleep(100);
}
```

### 3. AIProviderHttpIntegrationTest - HTTP 调用测试

**文件**: `src/test/java/com/github/intellijjavadocai/ai/AIProviderHttpIntegrationTest.java`

**测试场景**:

1. ✅ 成功的 HTTP 请求和响应
2. ✅ 401 未授权错误
3. ✅ 429 请求过多错误（Rate Limit）
4. ✅ 500 服务器错误
5. ✅ 重试机制
6. ✅ 网络连接错误
7. ✅ 响应解析错误
8. ✅ Ollama Provider（不需要 API Key）

#### 3.1 使用 MockWebServer

MockWebServer 是一个轻量级的 HTTP 服务器，用于测试：

```java
private MockWebServer mockServer;

@BeforeEach
void setUp() throws IOException {
    // 启动 Mock 服务器
    mockServer = new MockWebServer();
    mockServer.start();
    
    // 配置 Settings 使用 Mock 服务器的 URL
    settings.baseUrl = mockServer.url("/").toString();
}

@AfterEach
void tearDown() throws IOException {
    // 关闭服务器
    mockServer.shutdown();
}
```

#### 3.2 模拟 API 响应

```java
@Test
void testSuccessfulDocumentationGeneration() {
    // 1. 准备 Mock 响应（OpenAI 格式）
    String mockResponse = """
        {
            "choices": [{
                "message": {
                    "content": "/** 测试文档 */"
                }
            }]
        }
        """;
    
    // 2. 添加到队列
    mockServer.enqueue(new MockResponse()
        .setResponseCode(200)
        .setBody(mockResponse)
        .addHeader("Content-Type", "application/json"));
    
    // 3. 调用 API
    String result = provider.generateDocumentation(
        "public void test() {}",
        DocumentationType.METHOD,
        "java"
    );
    
    // 4. 验证结果
    assertThat(result).contains("测试文档");
}
```

#### 3.3 验证请求内容

```java
@Test
void testRequestValidation() throws Exception {
    mockServer.enqueue(new MockResponse()
        .setResponseCode(200)
        .setBody("{\"choices\":[{\"message\":{\"content\":\"ok\"}}]}"));
    
    provider.generateDocumentation(
        "test code", DocumentationType.METHOD, "java");
    
    // 获取发送的请求
    RecordedRequest request = mockServer.takeRequest();
    
    // 验证 HTTP 方法
    assertThat(request.getMethod()).isEqualTo("POST");
    
    // 验证路径
    assertThat(request.getPath()).isEqualTo("/chat/completions");
    
    // 验证请求头
    assertThat(request.getHeader("Authorization"))
        .isEqualTo("Bearer test-api-key");
    assertThat(request.getHeader("Content-Type"))
        .contains("application/json");
    
    // 验证请求体
    String body = request.getBody().readUtf8();
    JSONObject json = new JSONObject(body);
    assertThat(json.getString("model")).isEqualTo("qwen-max");
    assertThat(json.getDouble("temperature")).isEqualTo(0.1);
}
```

#### 3.4 测试错误场景

##### 401 未授权

```java
@Test
void testUnauthorizedError() {
    mockServer.enqueue(new MockResponse()
        .setResponseCode(401)
        .setBody("{\"error\": {\"message\": \"Invalid API key\"}}"));
    
    assertThatThrownBy(() -> provider.generateDocumentation(...))
        .isInstanceOf(AIServiceException.class)
        .hasMessageContaining("Invalid API Key")
        .extracting(e -> ((AIServiceException) e).getErrorCode())
        .isEqualTo(ErrorCode.INVALID_API_KEY);
}
```

##### 429 Rate Limit

```java
@Test
void testRateLimitError() {
    mockServer.enqueue(new MockResponse()
        .setResponseCode(429)
        .setBody("{\"error\": {\"message\": \"Rate limit exceeded\"}}"));
    
    assertThatThrownBy(() -> provider.generateDocumentation(...))
        .isInstanceOf(AIServiceException.class)
        .hasMessageContaining("Rate limit");
}
```

#### 3.5 测试重试机制

```java
@Test
void testRetryMechanism() {
    // 第一次失败
    mockServer.enqueue(new MockResponse()
        .setResponseCode(500)
        .setBody("{\"error\": {\"message\": \"Error\"}}"));
    
    // 第二次成功
    mockServer.enqueue(new MockResponse()
        .setResponseCode(200)
        .setBody("{\"choices\":[{\"message\":{\"content\":\"ok\"}}]}"));
    
    String result = provider.generateDocumentation(...);
    
    // 验证成功
    assertThat(result).contains("ok");
    
    // 验证重试了
    assertThat(mockServer.getRequestCount()).isEqualTo(2);
}
```

#### 3.6 测试网络错误

```java
@Test
void testNetworkError() throws IOException {
    // 关闭服务器模拟网络错误
    mockServer.shutdown();
    
    assertThatThrownBy(() -> provider.generateDocumentation(...))
        .isInstanceOf(AIServiceException.class)
        .hasMessageContaining("Network error")
        .extracting(e -> ((AIServiceException) e).getErrorCode())
        .isEqualTo(ErrorCode.NETWORK_ERROR);
}
```

## 🚀 运行测试

### 运行所有集成测试

```bash
# 运行所有测试
./gradlew test

# 只运行集成测试
./gradlew test --tests "*IntegrationTest"

# 运行特定的测试类
./gradlew test --tests "TaskExecutorIntegrationTest"
./gradlew test --tests "AIProviderHttpIntegrationTest"

# 运行特定的测试方法
./gradlew test --tests "TaskExecutorIntegrationTest.testInsertJavaDocForMethodWithoutExistingComment"
```

### 在 IntelliJ IDEA 中运行

1. 打开测试文件
2. 右键点击类名或方法名
3. 选择 "Run 'TestClassName'" 或 "Run 'testMethodName()'"
4. 或使用快捷键 `Ctrl + Shift + F10` (Windows/Linux) 或 `⌘ + Shift + R` (macOS)

### 调试测试

```bash
# 使用调试模式
./gradlew test --debug-jvm --tests "TaskExecutorIntegrationTest"
```

在 IDEA 中：

1. 设置断点
2. 右键选择 "Debug 'TestClassName'"
3. 单步调试查看 PSI 树的变化

## 📖 学习要点总结

### IntelliJ Platform SDK 核心概念

#### 1. PSI (Program Structure Interface)

- **定义**: 代码的语义树表示
- **层次结构**: File → Class → Method/Field → Statement → Expression
- **访问规则**: 必须在 Read Action 中读取
- **修改规则**: 必须在 Write Action 中修改

#### 2. Document

- **定义**: 文件的文本表示
- **用途**: 直接操作文本内容
- **同步**: 修改后需调用 `commitDocument` 同步到 PSI

#### 3. VirtualFile

- **定义**: 文件系统的抽象表示
- **用途**: 文件 I/O 操作
- **关系**: `VirtualFile` ↔ `Document` ↔ `PsiFile`

#### 4. Project & Module

- **Project**: IDE 项目的顶层容器
- **Module**: 项目的子模块
- **Services**: 项目级别的服务（如 PsiManager）

### 测试最佳实践

#### 1. 使用 Fixture

```java
// fixture 提供完整的测试环境
PsiFile file = myFixture.configureByText("Test.java", content);
myFixture.type("code");  // 模拟输入
myFixture.complete();    // 模拟代码补全
```

#### 2. 处理异步操作

```java
// 等待所有异步操作完成
PsiDocumentManager.getInstance(project).commitAllDocuments();
UIUtil.dispatchAllInvocationEvents();
```

#### 3. 使用 Mock

```java
// Mock 外部依赖
private void injectMock(Object target, String fieldName, Object mock) {
    Field field = target.getClass().getDeclaredField(fieldName);
    field.setAccessible(true);
    field.set(target, mock);
}
```

#### 4. 验证结果

```java
// 使用 AssertJ 进行流畅的断言
assertThat(result)
    .isNotNull()
    .isNotEmpty()
    .contains("expected text");
```

## 🔍 常见问题

### Q1: 测试中 PSI 元素为 null

**原因**: 没有在 Read Action 中访问 PSI

**解决**:

```java
// ❌ 错误
PsiMethod method = psiClass.getMethods()[0];

// ✅ 正确
PsiMethod method = runReadAction(() -> 
    psiClass.getMethods()[0]);
```

### Q2: Document 修改后 PSI 没有更新

**原因**: 没有调用 `commitDocument`

**解决**:

```java
Document doc = getDocument(file);
doc.insertString(0, "text");
// 必须提交
PsiDocumentManager.getInstance(project).commitDocument(doc);
```

### Q3: 异步操作测试不稳定

**原因**: 测试在操作完成前就进行了验证

**解决**:

```java
// 等待异步操作
waitForPendingWrites();
// 或使用 PlatformTestUtil.dispatchAllEventsInIdeEventQueue()
```

### Q4: MockWebServer 端口冲突

**原因**: 上一个测试的服务器没有正确关闭

**解决**:

```java
@AfterEach
void tearDown() throws IOException {
    if (mockServer != null) {
        mockServer.shutdown();
        mockServer = null;
    }
}
```

## 📚 参考资料

### 官方文档

- [IntelliJ Platform SDK](https://plugins.jetbrains.com/docs/intellij/welcome.html)
- [Testing Plugins](https://plugins.jetbrains.com/docs/intellij/testing-plugins.html)
- [PSI Overview](https://plugins.jetbrains.com/docs/intellij/psi.html)
- [Documents](https://plugins.jetbrains.com/docs/intellij/documents.html)

### 相关项目

- [MockWebServer](https://github.com/square/okhttp/tree/master/mockwebserver)
- [AssertJ](https://assertj.github.io/doc/)

### 推荐阅读顺序

1. 先看 `BasePlatformTestCase` - 了解基础 API
2. 再看 `TaskExecutorIntegrationTest` - 学习 PSI 操作
3. 最后看 `AIProviderHttpIntegrationTest` - 学习 HTTP 测试


