# 线程安全问题修复说明

## 📋 问题描述

### 错误信息

```
java.lang.Throwable: Read access is allowed from inside read-action (or EDT) only 
(see com.intellij.openapi.application.Application.runReadAction())
	at com.intellij.psi.impl.source.PsiMethodImpl.getDocComment(PsiMethodImpl.java:257)
	at dev.dong4j.zeka.stack.idea.plugin.task.TaskExecutor.shouldSkip(TaskExecutor.java:148)
	at dev.dong4j.zeka.stack.idea.plugin.task.TaskExecutor.processTask(TaskExecutor.java:105)
```

### 问题根源

在 `TaskExecutor.shouldSkip()` 方法中，代码尝试在后台线程中直接访问 PSI 元素：

```java
private boolean shouldSkip(@NotNull DocumentationTask task) {
    if (!settings.skipExisting) {
        return false;
    }

    PsiElement element = task.getElement();

    // 检查是否已有文档
    if (element instanceof PsiDocCommentOwner) {
        PsiDocComment docComment = ((PsiDocCommentOwner) element).getDocComment();  // ❌ 错误！
        return docComment != null;
    }

    return false;
}
```

**问题**：

- ❌ `shouldSkip()` 在后台线程（`Task.Backgroundable`）中被调用
- ❌ `getDocComment()` 访问 PSI 树结构
- ❌ PSI 访问必须在 read-action 或 EDT 中执行

---

## ✅ 解决方案

### IntelliJ Platform 线程模型

IntelliJ Platform 使用严格的线程模型来保护 PSI（Program Structure Interface）：

1. **Read-Action**：读取 PSI 数据时必须在 read-action 中
2. **Write-Action**：修改 PSI 数据时必须在 write-action 中（且必须在 EDT 中）
3. **EDT (Event Dispatch Thread)**：UI 操作和 write-action 必须在 EDT 中

### 修复代码

**文件**：`src/main/java/com/github/intellijjavadocai/task/TaskExecutor.java`

**修改前**：

```java
private boolean shouldSkip(@NotNull DocumentationTask task) {
    if (!settings.skipExisting) {
        return false;
    }

    PsiElement element = task.getElement();

    // 检查是否已有文档
    if (element instanceof PsiDocCommentOwner) {
        PsiDocComment docComment = ((PsiDocCommentOwner) element).getDocComment();
        return docComment != null;
    }

    return false;
}
```

**修改后**：

```java
private boolean shouldSkip(@NotNull DocumentationTask task) {
    if (!settings.skipExisting) {
        return false;
    }

    // PSI 访问必须在 read-action 中
    return ApplicationManager.getApplication().runReadAction((Computable<Boolean>) () -> {
        PsiElement element = task.getElement();

        // 检查是否已有文档
        if (element instanceof PsiDocCommentOwner) {
            PsiDocComment docComment = ((PsiDocCommentOwner) element).getDocComment();
            return docComment != null;
        }

        return false;
    });
}
```

**关键变化**：

1. ✅ 使用 `ApplicationManager.getApplication().runReadAction()` 包装 PSI 访问
2. ✅ 使用 `Computable<Boolean>` 返回结果
3. ✅ 添加了必要的导入：`import com.intellij.openapi.util.Computable;`

---

## 🔍 为什么需要 Read-Action

### PSI 的并发访问控制

IntelliJ Platform 的 PSI 系统需要处理以下并发场景：

1. **用户编辑代码** - 在 EDT 中修改 PSI
2. **后台索引** - 在后台线程中读取 PSI
3. **代码分析** - 在后台线程中读取 PSI
4. **插件功能** - 可能在任何线程中访问 PSI

为了防止并发访问导致的数据不一致，IntelliJ Platform 使用 **读写锁机制**：

- **Read-Lock**：允许多个线程同时读取 PSI
- **Write-Lock**：独占访问，用于修改 PSI

### 为什么 getDocComment() 需要 Read-Action

```java
// 这个调用链需要访问 PSI 树结构
element.getDocComment()
  → PsiMethodImpl.getDocComment()
    → PsiFileImpl.getStubTree()  // 访问 PSI 内部数据结构
      → assertReadAccessAllowed()  // 检查是否在 read-action 中
        → 如果不在，抛出异常！ ❌
```

---

## 📊 修复对比

### Before（错误的方式）

```
后台线程 (Background Thread)
  └─ processTask()
      └─ shouldSkip()
          └─ getDocComment()  ❌ 直接访问 PSI
              └─ 抛出异常: "Read access is allowed from inside read-action only"
```

### After（正确的方式）

```
后台线程 (Background Thread)
  └─ processTask()
      └─ shouldSkip()
          └─ runReadAction()  ✅ 获取 read-lock
              └─ getDocComment()  ✅ 在 read-action 中安全访问 PSI
```

---

## 🎯 相关代码检查

### 其他 PSI 访问点是否安全？

让我们检查 `TaskExecutor` 中的其他 PSI 访问：

#### 1. `getInsertPosition()` ✅ 安全

```java
private int getInsertPosition(@NotNull PsiElement element) {
    if (element instanceof PsiMethod) {
        return ((PsiMethod) element).getModifierList().getTextRange().getStartOffset();
    }
    // ...
}
```

**为什么安全**：

- 在 `insertDocumentation()` 方法中调用
- `insertDocumentation()` 在 `invokeLater()` (EDT) 中执行
- EDT 中可以安全访问 PSI

#### 2. `insertDocumentation()` ✅ 安全

```java
private void insertDocumentation(...) {
    ApplicationManager.getApplication().invokeLater(() -> {  // ← 在 EDT 中
        // ...
        ApplicationManager.getApplication().runWriteAction(() -> {  // ← Write-action
            // 修改 PSI
            document.insertString(...);
            // 格式化代码
            CodeStyleManager.getInstance(project).reformatText(...);
        });
    });
}
```

**为什么安全**：

- 在 EDT 中执行
- 使用 `runWriteAction()` 进行修改
- 完全符合 IntelliJ Platform 的线程模型

---

## 📚 IntelliJ Platform 线程安全最佳实践

### 1. 读取 PSI 数据

```java
// ✅ 正确：使用 runReadAction
ApplicationManager.getApplication().runReadAction(() -> {
    PsiElement element = ...;
    String text = element.getText();
    // 读取 PSI 数据
});

// ✅ 正确：返回值
String result = ApplicationManager.getApplication().runReadAction((Computable<String>) () -> {
    return element.getText();
});
```

### 2. 修改 PSI 数据

```java
// ✅ 正确：在 EDT 中使用 runWriteAction
ApplicationManager.getApplication().invokeLater(() -> {
    ApplicationManager.getApplication().runWriteAction(() -> {
        // 修改 PSI
        document.insertString(...);
    });
});
```

### 3. 后台任务中访问 PSI

```java
// ✅ 正确：Task.Backgroundable 中访问 PSI
public class MyTask extends Task.Backgroundable {
    @Override
    public void run(@NotNull ProgressIndicator indicator) {
        // 后台线程
        
        // 需要访问 PSI？使用 runReadAction
        ApplicationManager.getApplication().runReadAction(() -> {
            PsiElement element = ...;
            // 读取 PSI
        });
        
        // 需要修改 PSI？使用 invokeLater + runWriteAction
        ApplicationManager.getApplication().invokeLater(() -> {
            ApplicationManager.getApplication().runWriteAction(() -> {
                // 修改 PSI
            });
        });
    }
}
```

---

## ✅ 验证

### 1. 编译检查

```bash
./gradlew compileJava
```

**结果**：✅ 编译成功

```
BUILD SUCCESSFUL in 10s
4 actionable tasks: 3 executed, 1 up-to-date
```

### 2. 运行测试

**操作**：

1. 打开一个 Java 文件
2. 在编辑器中右键选择 "Generate JavaDoc with AI"
3. 观察是否还有线程安全异常

**预期**：✅ 不再出现 "Read access is allowed..." 异常

---

## 📝 总结

### 问题

- ❌ 在后台线程中直接访问 PSI 元素的 `getDocComment()` 方法
- ❌ 违反了 IntelliJ Platform 的线程安全规则
- ❌ 抛出 "Read access is allowed from inside read-action only" 异常

### 解决方案

- ✅ 使用 `ApplicationManager.getApplication().runReadAction()` 包装 PSI 访问
- ✅ 确保所有 PSI 读取操作都在 read-action 中执行
- ✅ 遵循 IntelliJ Platform 的线程模型

### 影响

- ✅ 修复了运行时异常
- ✅ 提高了插件的稳定性
- ✅ 符合 IntelliJ Platform 的最佳实践
- ✅ 确保线程安全

---

## 🔗 参考资料

1. **IntelliJ Platform SDK**
    - [Threading in IntelliJ Platform](https://plugins.jetbrains.com/docs/intellij/general-threading-rules.html)
    - [PSI and Read/Write Actions](https://plugins.jetbrains.com/docs/intellij/psi-files.html#accessing-psi)

2. **相关 API**
    - `ApplicationManager.getApplication().runReadAction()`
    - `ApplicationManager.getApplication().runWriteAction()`
    - `ApplicationManager.getApplication().invokeLater()`
    - `Computable<T>` - 用于从 read-action 返回值
